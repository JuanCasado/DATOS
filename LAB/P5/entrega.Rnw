\documentclass [a4paper] {article}
\usepackage[utf8]{inputenc}
\title{Ciencia de datos, práctica 5}
\author{Juan Casado Ballesteros, Samuel García Gonzalez, Iván Anaya Martín}
\begin{document}
\maketitle

\begin{abstract}
Pendiente
\end{abstract}

\newpage
<<functions, echo=False>>=
frecuenciaAbsoluta <- function(data){
  uniquedata<-unique(data)
  uniquedata<- sort(uniquedata)
  newdata<- vector(mode="numeric", length=0)
  for (value in uniquedata) {
    ammount<-length(data[data==value])
    newdata<-c(newdata, ammount)
  }
  setNames(newdata, uniquedata)
}
frecuenciaRelativa <- function(data){
  frecuencia <-frecuenciaAbsoluta(data)
  uniquedata<-unique(data)
  uniquedata<- sort(uniquedata)
  newdata <- vector(mode="numeric", length=0)
  for (value in 1:length(uniquedata)) {
    newdata <- c(newdata, frecuencia[value]/length(data))
  }
  setNames(newdata, uniquedata)
}
plotFrecuencyData <- function(data, xlabel="") {
  uniquedata<-unique(data)
  frecuencia_relativa <- as.table(frecuenciaRelativa(data))
  media_ <- mediaAritmetica(data)
  desviacion_tipica_ <- desviacionTipica(data)
  tchebychev_min <- media_-2*desviacion_tipica_
  tchebychev_max <- media_+2*desviacion_tipica_
  min_range = min(tchebychev_min, min(uniquedata))
  max_range = max(tchebychev_min, max(uniquedata))
  plot(frecuencia_relativa, type="h", xlab=xlabel, xlim=c(min_range,max_range))
  abline (v=c(media_, tchebychev_min, tchebychev_max), 
          col=c("blue", "gray", "gray"), lty=c(2,2,2,3,3),
          lwd=c(2,2,2,1,1))
  legend ("topright", legend=c("media", "2*desviación típica"),
          fill=c("blue","gray"))
}
mediaAritmetica <- function(data){
  acc <- 0
  for (value in data) {
    acc <- acc + value
  }
  acc / length(data)
}
varianza <- function(data){
  v_media <- mediaAritmetica(data)
  acc = 0
  for (value in data){
    acc <- acc + (value - v_media)^2
  }
  acc/length(data)
}
desviacionTipica <- function (data) {
  varianza(data)^(1/2)
}
@

\newpage
\section{K-vecinos sobre la muestra proporcionada para obtener outliers}

Aplicaremos el algoritmo k-vecinos sobre la muestra que tenemos.
Este algoritmo identificará de forma supervisada en la muestra datos anómalos, para poder obtener los outliers.
En primer lugar deberemos cargar esta desde un archivo .txt.
<<cargar_datos_kvecinos>>=
datos1 <- read.table("datos1.txt")
datos1
@

En segundo lugar calculamos las distancias euclídeas entre todos los puntos
<<distancias>>=
distancias <- as.matrix(dist(datos1))
distancias
@

Posteriormente, ordenamos las distancias de cada punto a todos los demás.
<<distancias_ordenar>>=
for(i in 1:length(distanciasordenadas[,1])){
  distancias[,i] <- sort(distancias[,i])
}
distanciasordenadas <- distancias
@

Como último paso, reordenamos la matriz para organizarla en función de la distancia
de cada punto a su vecino número 1,2,3...etc. Tras haber organizado la matriz, buscamos en el tercer
vecino, que es el valor k que hemos usado en nuestro análisis para poder identificar los outliers.
<<ordenacionfinalconoutlier>>=
outliers_kvecinos = list()
for(i in 1:length(distanciasordenadas[,1])){
outliers_kvecinos = list()
  if(distanciasordenadas[4,i]>2.5){
    outliers_kvecinos[[length(outliers_kvecinos)+1]] <- datos1[i,]
  }
}
outliers_kvecinos
@



\section{Deteccion de datos anómalos sobre la resistencia }

<<cargar_datos>>=
datos2 <- read.table("datos2.txt")
datos2 <- data.frame(datos2)
datos2
@

\begin{center}
<<plot_caja_bigotes, fig=TRUE>>=
boxplot(datos2$Resistencia, range=1.5, horizontal = TRUE)
@
\end{center}

\begin{center}
<<plot_caja_bigotes, fig=TRUE>>=
boxplot(datos2$Densidad, range=1.5, horizontal = TRUE)
@
\end{center}

\newpage
\section{Dispersión sobre la densidad, desviación típica}

<<desviacion_tipica>>=
datos2 <- read.table("datos2.txt")
@

\begin{center}
<<desviacion_tipica_densidad_plot, fig=TRUE>>=
plotFrecuencyData(datos2$Densidad)
@
\end{center}
<<desviacion_tipica_densidad>>=
int <- c(mediaAritmetica(datos2$Densidad) - 2*desviacionTipica(datos2$Densidad), mediaAritmetica(datos2$Densidad) + 2*desviacionTipica(datos2$Densidad))
outliers_desviacion = list()
for(i in 1:length(datos2$Densidad)) {
  if ((datos2$Densidad[i]<int[1]) || (datos2$Densidad[i]>int[2])) {
    outliers_desviacion[[length(outliers_desviacion)+1]] <- t(matrix(c(i, datos2[i,]$Densidad), dimnames=list(c("Indice","Densidad"))))
  }
}
outliers_desviacion
@

\begin{center}
<<desviacion_tipica_resistencia_plot, fig=TRUE>>=
plotFrecuencyData(datos2$Resistencia)
@
\end{center}
<<desviacion_tipica_resistencia>>=
int <- c(mediaAritmetica(datos2$Resistencia) - 2*desviacionTipica(datos2$Resistencia), mediaAritmetica(datos2$Resistencia) + 2*desviacionTipica(datos2$Resistencia))
outliers_desviacion = list()
for(i in 1:length(datos2$Resistencia)) {
  if ((datos2$Resistencia[i]<int[1]) || (datos2$Resistencia[i]>int[2])) {
    outliers_desviacion[[length(outliers_desviacion)+1]] <- t(matrix(c(i, datos2[i,]$Resistencia), dimnames=list(c("Indice","Resistencia"))))
  }
}
outliers_desviacion
@

\end{document}


\section{detección de datos anómalos sobre la regresión de la densidad en función de la resistencia}

En este análisis detectamos los outliers utilizando la recta de regresión y
el error estándar de los residuos. Como primer paso leemos la tabla de los datos.
<<cargar_datos_regresion>>=
datos2 <- read.table("datos2.txt")
datos2
@
Seguidamente calculamos la recta de regresión sobre los datos.
<<rectaregresion>>=
(dFr=lm(datos2$Densidad~datos2$Resistencia))
@
Posteriormente, obtenemos los residuos calculados a partir de la recta de regresión.
<<residuos>>=
(res=summary(dFr)$residuals)
@
Para finalizar, calculamos el error estándar de los residuos, y a partir de él comparamos cada
uno para comprobar si algún residuo es 2 veces mayor que el error estándar. Si se da el caso, 
podemos considerar ese punto como un outlier. 
<<residuooutlier>>=
(sr=sqrt(sum(res^2)/7))
outliers_regresion = list()
for(i in 1:7){
  if(abs(res[i])>2*sr){
    outliers_kmeans[[length(outliers_kmeans)+1]] <- datos2[i,]
  }
}
outliers_kmeans
@
